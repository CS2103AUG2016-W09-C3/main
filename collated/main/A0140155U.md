# A0140155U
###### \java\seedu\address\commons\events\model\FilePathChangedEvent.java
``` java
package seedu.address.commons.events.model;

import seedu.address.commons.events.BaseEvent;

/** Indicates the filepath of the TaskBook has changed*/
public class FilePathChangedEvent extends BaseEvent {

    public final String filePath;

    public FilePathChangedEvent (String filePath){
        this.filePath = filePath;
    }

    @Override
    public String toString() {
        return "new file path: " + filePath;
    }
}
```
###### \java\seedu\address\commons\events\model\PresetChangedEvent.java
``` java
package seedu.address.commons.events.model;

import seedu.address.commons.events.BaseEvent;
import seedu.address.model.ReadOnlyTaskBook;
import seedu.address.model.UserPrefs;

/** Indicates the TaskBook in the model has changed*/
public class PresetChangedEvent extends BaseEvent {

    public final UserPrefs data;

    public PresetChangedEvent(UserPrefs data){
        this.data = data;
    }

    @Override
    public String toString() {
        return "number of presets: " + data.commandPresets.size();
    }
}
```
###### \java\seedu\address\commons\events\ui\CommandPresetSelectedEvent.java
``` java
package seedu.address.commons.events.ui;

import seedu.address.commons.events.BaseEvent;
import seedu.address.model.CommandPreset;

/**
 * Indicates a command preset card clicked
 */
public class CommandPresetSelectedEvent extends BaseEvent {

    private final CommandPreset command;
    
    public CommandPresetSelectedEvent(CommandPreset command) {
        this.command = command;
    }
    
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public String getCommand() {
        return command.getCommand();
    }
}
```
###### \java\seedu\address\commons\exceptions\StateException.java
``` java
package seedu.address.commons.exceptions;

/**
 * Signals that a state could not be loaded.
 */
public class StateException extends Exception {
    /**
     * @param message should contain relevant information on why the state failed to load
     */
    public StateException(String message) {
        super(message);
    }
}
```
###### \java\seedu\address\logic\commands\Command.java
``` java
    public static final String[] REQUIRED_PARAMS = {};
    public static final String[] POSSIBLE_PARAMS = {".*"};
    
    /**
     * Returns true if the command creates a new state of the model.
     * The command creates a new state if the command has the potential to modify the model data (e.g. add, delete)
     * Commands that do not modify data return false (e.g. list, help).
     * The only exceptions are the "undo" and "redo" command, which modify data but do not create new states.
     * 
     * @return whether or not the command creates a new state
     */

    public abstract boolean createsNewState();
```
###### \java\seedu\address\logic\commands\DoneCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.UnmodifiableObservableList;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.tag.Tag;
import seedu.address.model.tag.UniqueTagList;
import seedu.address.model.task.*;
import seedu.address.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.address.model.task.UniqueTaskList.TaskNotFoundException;

import java.util.HashSet;
import java.util.Set;

/**
 * Marks a task in the task book as done.
 */
public class DoneCommand extends Command {

    public static final String COMMAND_WORD = "done";

    public static final String[] REQUIRED_PARAMS = {};
    public static final String[] POSSIBLE_PARAMS = {};
    
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Marks a task as done.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_SUCCESS = "Task marked as %1$s: %2$s";
    public static final String MESSAGE_EXCEPTION = "Error executing command.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task book";
    public static final String MESSAGE_ALREADY_DONE_TASK = "Task is already done.";

    private final int targetIndex;

    /**
     * Convenience constructor using raw values for adding 
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public DoneCommand(int targetIndex) throws IllegalValueException {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);
        if(taskToDelete.getDoneFlag().isDone()){
            return new CommandResult(MESSAGE_ALREADY_DONE_TASK);
        }
        Task toAdd = null;
        try {
            DoneFlag newFlag = new DoneFlag(DoneFlag.DONE);
            if(!taskToDelete.isDated()){
                toAdd = new Task(taskToDelete.getName(), taskToDelete.getPriority(), taskToDelete.getInformation(), 
                            newFlag, taskToDelete.getTags());
            }else{
                ReadOnlyDatedTask datedTaskToDelete = (ReadOnlyDatedTask) taskToDelete;
                toAdd = new DatedTask(datedTaskToDelete.getName(), datedTaskToDelete.getDateTime(),
                        datedTaskToDelete.getLength(), datedTaskToDelete.getRecurrance(),
                        datedTaskToDelete.getPriority(), datedTaskToDelete.getInformation(), 
                        newFlag, datedTaskToDelete.getTags());
            }
            model.deleteTask(taskToDelete);
            model.addTaskToIndex(toAdd, targetIndex - 1);
            //model.addTask(toAdd);
        } catch (DuplicateTaskException e) {
            assert false : "Can't add a duplicate task.";
            return new CommandResult(MESSAGE_EXCEPTION);
        } catch (IllegalValueException e) {
            // Should never happen
            assert false : "DoneFlag class is corrupt. Call a programmer.";
            return new CommandResult(MESSAGE_EXCEPTION);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
            return new CommandResult(MESSAGE_EXCEPTION);
        } 
        
        return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd.getDoneFlag().toString(), toAdd.getName()));

    }


    @Override
    public boolean createsNewState() {
        return true;
    }
}
```
###### \java\seedu\address\logic\commands\FavoriteCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.CommandPreset;

/**
 * Adds a favorite command to the preset list.
 */
public class FavoriteCommand extends Command {

    public static final String COMMAND_WORD = "favorite";

    public static final String[] REQUIRED_PARAMS = {"c"};
    public static final String[] POSSIBLE_PARAMS = {"c"};
    
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a favorite command to the preset list.\n"
            + "Parameters: DESCRIPTION c/COMMAND\n"
            + "Example: " + COMMAND_WORD
            + " List all tasks c/list df/all";

    public static final String MESSAGE_SUCCESS = "Added favorite: %1$s";

    private final CommandPreset commandPreset;

    public FavoriteCommand(String command, String description)
            throws IllegalValueException {
        this.commandPreset = new CommandPreset(command, description);
    }


    @Override
    public CommandResult execute() {
        assert model != null;
        model.addPreset(commandPreset);
        return new CommandResult(String.format(MESSAGE_SUCCESS, commandPreset.getCommand()));

    }

    @Override
    public boolean createsNewState() {
        return false;
    }

}
```
###### \java\seedu\address\logic\commands\FilepathCommand.java
``` java
package seedu.address.logic.commands;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.address.commons.exceptions.IllegalValueException;
/**
 * Changes the filepath of the task book.
 */
public class FilepathCommand extends Command {

    public static final String COMMAND_WORD = "filepath";

    public static final String[] REQUIRED_PARAMS = {};
    public static final String[] POSSIBLE_PARAMS = {};
    
    public static final Pattern FILEPATH_REGEX = Pattern.compile(
            "^([a-zA-Z]\\:\\\\)?[^\\\\:\\*\\|\\\"<>\\?\\n]+(\\\\[^\\\\:\\*\\|\\\"<>\\?\\n]+)*\\.xml$");
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Changes the filepath. "
            + "Parameter: FILEPATH"
            + "Parameter should be a valid file name, ending in .xml."
            + "Examples: taskbook.xml, data\\taskbook.xml, C:\\data\\taskbook.xml";

    public static final String MESSAGE_SUCCESS = "File path changed to %1$s";
    public static final String MESSAGE_INVALID_PATH = "Invalid file path. Parameter should be a valid file name, ending in .xml.\n" + 
                                                    "Examples: taskbook.xml, data\\taskbook.xml, C:\\data\\taskbook.xml";

    private final String filePath;

    public FilepathCommand(String filePath){
        this.filePath = filePath;
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        assert filePath != null;
        final Matcher matcher = FILEPATH_REGEX.matcher(filePath);
        if (!matcher.matches()) {
            return new CommandResult(MESSAGE_INVALID_PATH);
        }
        model.changeFilePath(filePath);
        return new CommandResult(String.format(MESSAGE_SUCCESS, filePath));

    }

    @Override
    public boolean createsNewState() {
        return true;
    }

}
```
###### \java\seedu\address\logic\commands\RedoCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.commons.exceptions.StateException;

/**
 * Adds a tasks to the task book.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";

    public static final String[] REQUIRED_PARAMS = {};
    public static final String[] POSSIBLE_PARAMS = {""};
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Redoes a command that was undone. ";
    public static final String MESSAGE_SUCCESS = "Redid previous command \"%1$s\"";

    public RedoCommand(){
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            String commandString = model.loadNextState();
            return new CommandResult(String.format(MESSAGE_SUCCESS, commandString));
        } catch (StateException e) {
            return new CommandResult(e.getMessage());
        }

    }

    @Override
    public boolean createsNewState() {
        return false; 
    }
}
```
###### \java\seedu\address\logic\commands\UndoCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.commons.exceptions.StateException;

/**
 * Adds a tasks to the task book.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String[] REQUIRED_PARAMS = {};
    public static final String[] POSSIBLE_PARAMS = {""};
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undoes the previous command. ";
    public static final String MESSAGE_SUCCESS = "Undid previous command \"%1$s\"";

    public UndoCommand(){
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            String commandString = model.loadPreviousState();
            return new CommandResult(String.format(MESSAGE_SUCCESS, commandString));
        } catch (StateException e) {
            return new CommandResult(e.getMessage());
        }
    }

    @Override
    public boolean createsNewState() {
        return false; 
    }
}
```
###### \java\seedu\address\logic\commands\UndoneCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.UnmodifiableObservableList;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.tag.Tag;
import seedu.address.model.tag.UniqueTagList;
import seedu.address.model.task.*;
import seedu.address.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.address.model.task.UniqueTaskList.TaskNotFoundException;

import java.util.HashSet;
import java.util.Set;

/**
 * Marks a task in the task list as undone.
 */
public class UndoneCommand extends Command {

    public static final String COMMAND_WORD = "undone";

    public static final String[] REQUIRED_PARAMS = {};
    public static final String[] POSSIBLE_PARAMS = {};
    
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Marks a task as undone.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_SUCCESS = "Task marked as %1$s: %2$s";
    public static final String MESSAGE_EXCEPTION = "Error executing command.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task book";
    public static final String MESSAGE_ALREADY_UNDONE_TASK = "Task is already undone.";

    private final int targetIndex;

    /**
     * Convenience constructor using raw values for adding 
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public UndoneCommand(int targetIndex) throws IllegalValueException {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);
        if(!taskToDelete.getDoneFlag().isDone()){
            return new CommandResult(MESSAGE_ALREADY_UNDONE_TASK);
        }
        
        Task toAdd = null;
        try {
            DoneFlag newFlag = new DoneFlag(DoneFlag.NOT_DONE);
            if(!taskToDelete.isDated()){
                toAdd = new Task(taskToDelete.getName(), taskToDelete.getPriority(), taskToDelete.getInformation(), 
                            newFlag, taskToDelete.getTags());
            }else{
                ReadOnlyDatedTask datedTaskToDelete = (ReadOnlyDatedTask) taskToDelete;
                toAdd = new DatedTask(datedTaskToDelete.getName(), datedTaskToDelete.getDateTime(),
                        datedTaskToDelete.getLength(), datedTaskToDelete.getRecurrance(),
                        datedTaskToDelete.getPriority(), datedTaskToDelete.getInformation(), 
                        newFlag, datedTaskToDelete.getTags());
            }
            model.deleteTask(taskToDelete);
            model.addTaskToIndex(toAdd, targetIndex - 1);
        } catch (DuplicateTaskException e) {
            assert false : "Can't add a duplicate task.";
            return new CommandResult(MESSAGE_EXCEPTION);
        } catch (IllegalValueException e) {
            // Should never happen
            assert false : "DoneFlag class is corrupt. Call a programmer.";
            return new CommandResult(MESSAGE_EXCEPTION);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
            return new CommandResult(MESSAGE_EXCEPTION);
        } 
        
        return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd.getDoneFlag().toString(), toAdd.getName()));

    }

    @Override
    public boolean createsNewState() {
        return true;
    }
}
```
###### \java\seedu\address\logic\commands\UnfavoriteCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.CommandPreset;

/**
 * Adds a favorite command to the preset list.
 */
public class UnfavoriteCommand extends Command {

    public static final String COMMAND_WORD = "unfavorite";

    public static final String[] REQUIRED_PARAMS = {};
    public static final String[] POSSIBLE_PARAMS = {};
    
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Removes a favorite command to the preset list.\n"
            + "Parameters: INDEX";

    public static final String MESSAGE_SUCCESS = "Removed favorite: %1$s";
    public static final String MESSAGE_OUT_OF_RANGE = "Index out of range.";

    private final int index;

    public UnfavoriteCommand(int index)
            throws IllegalValueException {
        this.index = index - 1;
    }


    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            String removedCommandDesc = model.removePreset(index);
            return new CommandResult(String.format(MESSAGE_SUCCESS, removedCommandDesc));
        } catch (IllegalValueException e) {
            return new CommandResult(MESSAGE_OUT_OF_RANGE);
        }

    }

    @Override
    public boolean createsNewState() {
        return false;
    }

}
```
###### \java\seedu\address\logic\LogicManager.java
``` java
    @Override
    public CommandResult execute(String commandText) {
        logger.info("----------------[USER COMMAND][" + commandText + "]");
        Command command = parser.parseCommand(commandText);
        command.setData(model);
        CommandResult cr = command.execute();
        if(command.createsNewState()){
            model.saveState(commandText);
        }
        return cr;
    }
```
###### \java\seedu\address\logic\parser\CommandParser.java
``` java
package seedu.address.logic.parser;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import seedu.address.commons.exceptions.IllegalValueException;

/**
 * Parses a command into values and parameters.
 */
public class CommandParser implements ParsedCommand{
    
    private static final String COMMAND_DELIMITER = " ";
    private static final String PARAM_DELIMITER = "/";
    public static final String VALUE_OUT_OF_BOUNDS_MESSAGE = "Value index out of bounds: %1$s";
    public static final String NO_PARAM_MESSAGE = "Could not find param: %1$s";
    
    /*
     * A command consists of values, followed by parameters.
     * A value is a string that does not contain a /.
     * A parameter consists of a param name and a param value, seperated by a / e.g name/value.
     * 
     * A param can have multiple values, when multiple params have the same name, all values
     * are group in one param.
     */
    
    // List of values
    private ArrayList<String> values = new ArrayList<>();
    // Param name -> list of param values
    private HashMap<String, ArrayList<String>> params = new HashMap<>();
    private final String command;
    
    public CommandParser(String command){
        this.command = command;
        loadFromString(command);
    }
    
    /**
     * Loads values and params from string.
     */
    private void loadFromString(String command){
        if(command == null || command.isEmpty()){
            return;
        }
        String[] splitted = command.split(COMMAND_DELIMITER);
        
        // Find all values
        int firstParamIndex = loadValues(splitted);
        // Find all params
        loadParams(splitted, firstParamIndex);
        
    }

    /**
     * Loads values from command.
     * Returns the index of the first param in the command.
     * 
     * i.e.
     * ["value1", "value2", "value3", "p1/param1", "p1/param1a", "p2/param2"]
     * Loads values = ["value1", "value2", "value3"] 
     * return 3
     */
    private int loadValues(String[] splitted) {
        // Load string tokens until we encounter a param token
        int index = 0;
        while(index < splitted.length && !isParamToken(splitted[index])){
            values.add(splitted[index]);
            index++;
        }
        return index;
    }

    /**
     * Loads params from command.
     * 
     * i.e.
     * ["value1", "value2", "value3", "p1/param1", "p1/param1a", "p2/param2"], firstParamIndex = 3
     * Loads params = {p1 : ["param1", "param1a"], p2 : ["param2"]} 
     */
    private void loadParams(String[] splitted, int firstParamIndex) {
        // This stores the param name
        String currentParam = null;
        // This stores the param value
        StringBuilder currentParamValue = new StringBuilder();
        for(int i = firstParamIndex; i < splitted.length; i++){
            String token = splitted[i];
            if(isParamToken(token)){
                // New param, flush the param value, add the old param and start over
                addParam(currentParam, currentParamValue.toString());
                int paramDelimIndex = token.indexOf(PARAM_DELIMITER);
                currentParam = token.substring(0, paramDelimIndex).toLowerCase();
                currentParamValue = new StringBuilder();
                currentParamValue.append(token.substring(paramDelimIndex + 1, token.length()));
            }else{
                // Not a param, add the token on to the value
                currentParamValue.append(COMMAND_DELIMITER);
                currentParamValue.append(token);
            }
        }
        addParam(currentParam, currentParamValue.toString());
    }


    /**
     * Adds a param to the param list.
     */
    private void addParam(String currentParam, String currentParamValue) {
        if(currentParam != null){
            if(!params.containsKey(currentParam)){
                // If list doesn't exist, create one
                params.put(currentParam, new ArrayList<>());
            }
            params.get(currentParam).add(currentParamValue);
        }
    }
    
    /**
     * Checks if a string token is a param.
     */
    private boolean isParamToken(String token){
        return token.contains(PARAM_DELIMITER);
    }

    /**
     * Retrieves the first param from the list corresponding to the param name.
     * Throws an error if the param name has no values.
     */
    @Override
    public String getParam(String paramName) throws IllegalValueException {
        if(!params.containsKey(paramName) || params.get(paramName).size() == 0){
            throw new IllegalValueException(String.format(NO_PARAM_MESSAGE, paramName));
        }
        return params.get(paramName).get(0);
    }
    
    /**
     * Retrieves the first param from the list corresponding to the param name.
     * If the param name has no values, return the default value.
     */
    @Override
    public String getParamOrDefault(String paramName, String defaultParam)  {
        if(!params.containsKey(paramName) || params.get(paramName).size() == 0){
            return defaultParam;
        }
        return params.get(paramName).get(0);
    }
    
    /**
     * Retrieves a list of params corresponding to the param name.
     * If the param name has no values, returns an empty list.
     */
    @Override
    public ArrayList<String> getAllParams(String paramName) {
        if(!params.containsKey(paramName) || params.get(paramName).size() == 0){
            return new ArrayList<String>();
        }
        ArrayList<String> readOnlyParamData = new ArrayList<> (params.get(paramName));
        return readOnlyParamData;
    }
    
    /**
     * Retrieves the very first value in the list.
     * Use when you expect only one value in the command.
     */
    @Override
    public String getValue() throws IllegalValueException {
        return getValue(0);
    }
    
    /**
     * Retrieves the nth value in the list.
     */
    @Override
    public String getValue(int index) throws IllegalValueException {
        if(index >= values.size()){
            throw new IllegalValueException(String.format(VALUE_OUT_OF_BOUNDS_MESSAGE, index));
        }
        return values.get(index);
    }

    /**
     * Get all values as an arraylist.
     */
    @Override
    public ArrayList<String> getAllValues(){
        ArrayList<String> readOnlyValues = new ArrayList<> (values);
        return readOnlyValues;
    }
    

    /**
     * Get all params as an arraylist.
     */
    @Override
    public ArrayList<String> getParamList(){
        ArrayList<String> readOnlyParams = new ArrayList<> (params.keySet());
        return readOnlyParams;
    }

    /**
     * Retrieves list of values joined with spaces.
     */
    @Override
    public String getValuesAsString() {
        return String.join(" ", values);
    }

    /**
     * Check if command contains all the params in the array.
     * Useful for checking if the command is valid.
     */
    @Override
    public boolean hasParams(String[] requiredParams) {
        for(String param : requiredParams){
            if(!params.containsKey(param)){
                return false;
            }
        }
        return true;
    }

    /**
     * Check if command has at least one value.
     * Useful for checking if the command is valid.
     */
    @Override
    public boolean hasValue() {
        return values.size() > 0;
    }
    
```
###### \java\seedu\address\logic\parser\CommandParser.java
``` java
    @Override
    public boolean hasUnnecessaryParams(String[] possibleParams) {
        for(String param : params.keySet()){
            if(!matchingParam(param.toLowerCase(), possibleParams)){
                return true;
            }
        }
        return false;
    }
    
    private boolean matchingParam(String param, String[] possibleParams){
        for(String possibleParam : possibleParams){
            if(param.toLowerCase().matches(possibleParam)){
                return true;
            }
        }
        return false;
    }
    
    public String getCommand(){
        return command;
    }
}
```
###### \java\seedu\address\logic\parser\ParsedCommand.java
``` java
package seedu.address.logic.parser;

import java.util.ArrayList;
import java.util.Iterator;

import seedu.address.commons.exceptions.IllegalValueException;

/*
 * Interface for a parsed command
 */
public interface ParsedCommand {
    
    /**
     * Retrieves the first param from the list corresponding to the param name.
     * Throws an error if the param name has no values.
     */
    String getParam(String paramName) throws IllegalValueException;

    /**
     * Retrieves the first param from the list corresponding to the param name.
     * If the param name has no values, return the default value.
     */
    String getParamOrDefault(String paramName, String defaultParam);

    /**
     * Get all params.
     */
    ArrayList<String> getParamList();
    
    /**
     * Retrieves the very first value in the list.
     * Use when you expect only one value in the command.
     */
    String getValue() throws IllegalValueException;

    /**
     * Retrieves the nth value in the list.
     */
    String getValue(int index) throws IllegalValueException;

    /**
     * Get all values.
     */
    ArrayList<String> getAllValues();

    /**
     * Retrieves a list of params corresponding to the param name.
     * If the param name has no values, returns an empty list.
     */
    ArrayList<String> getAllParams(String paramName);

    /**
     * Retrieves list of values joined with spaces.
     */
    String getValuesAsString();


    /**
     * Check if command contains all the params in the array.
     * Useful for checking if the command is valid.
     */
    boolean hasParams(String[] params);

    /**
     * Check if command has at least one value.
     * Useful for checking if the command is valid.
     */
    boolean hasValue();
    
```
###### \java\seedu\address\logic\parser\ParsedCommand.java
``` java
    /**
     * Check if command has value at the particular index
     * Useful for checking if the command is valid.
     */
    boolean hasUnnecessaryParams(String[] possibleParams);
    
    /** Returns entire command. */
    String getCommand();
}
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the done task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDone(ParsedCommand command) {
        try{
            Optional<Integer> index = parseIndex(command.getValue());
            if(!index.isPresent()){
                return new IncorrectCommand(
                        String.format(MESSAGE_INVALID_COMMAND_FORMAT, DoneCommand.MESSAGE_USAGE));
            }

            return new DoneCommand(index.get());
        }catch(IllegalValueException ex){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DoneCommand.MESSAGE_USAGE));
        }
    }
    
    /**
     * Parses arguments in the context of the undone task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareUndone(ParsedCommand command) {
        try{
            Optional<Integer> index = parseIndex(command.getValue());
            if(!index.isPresent()){
                return new IncorrectCommand(
                        String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoneCommand.MESSAGE_USAGE));
            }

            return new UndoneCommand(index.get());
        }catch(IllegalValueException ex){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoneCommand.MESSAGE_USAGE));
        }
    }
    
    /**
     * Parses arguments in the context of the favorite task command.
     */
    private Command prepareFavorite(ParsedCommand command) {
        try{
            if(!command.hasValue() || !command.hasParams(FavoriteCommand.REQUIRED_PARAMS)){
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FavoriteCommand.MESSAGE_USAGE));
            }
            
            // Work around because the command might have tokens which can be recognized by ParsedCommand as params.
            int paramIndex = command.getCommand().indexOf(" c/");
            String favCommand = command.getCommand().substring(paramIndex + 3, command.getCommand().length());
            return new FavoriteCommand(favCommand, command.getValuesAsString());
        }catch(IllegalValueException ex){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, FavoriteCommand.MESSAGE_USAGE));
        }
    }
   
    private Command prepareUnfavorite(ParsedCommand command) {
        try{
            Optional<Integer> index = parseIndex(command.getValue());
            if(!index.isPresent()){
                return new IncorrectCommand(
                        String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnfavoriteCommand.MESSAGE_USAGE));
            }

            return new UnfavoriteCommand(index.get());
        }catch(IllegalValueException ex){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnfavoriteCommand.MESSAGE_USAGE));
        }
    }
```
###### \java\seedu\address\MainApp.java
``` java
    @Subscribe
    public void handleFilePathChangedEvent(FilePathChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Config data changed, saving to file"));
        String oldFilePath = config.getTaskBookFilePath();
        try {
            storage.setTaskBookFilePath(event.filePath);
            storage.saveTaskBook(model.getTaskBook());
            config.setTaskBookFilePath(event.filePath);
            ConfigUtil.saveConfig(config, config.getConfigFilePath());
        } catch (IOException e) {
            storage.setTaskBookFilePath(oldFilePath);
            config.setTaskBookFilePath(oldFilePath);
            logger.warning("Failed to save config file, reverting to old : " + StringUtil.getDetails(e));
        }
    }
```
###### \java\seedu\address\model\CommandPreset.java
``` java
package seedu.address.model;

import java.io.Serializable;
/**
 * Command Preset class.
 * Used to store user's favourite commands.
 * Each preset stores a command and a description.
 */
public class CommandPreset implements Serializable{
    private final String command;
    private final String description;
    
    public CommandPreset(){
        this.command = "";
        this.description = "";
    }
    
    public CommandPreset(String command, String description){
        this.command = command;
        this.description = description;
    }
    
    public CommandPreset(CommandPreset commandPreset) {
        this.command = commandPreset.getCommand();
        this.description = commandPreset.getDescription();
    }

    public String getCommand() {
        return command;
    }
    
    public String getDescription() {
        return description;
    }
    
    @Override
    public String toString(){
        return command;
    }
}
```
###### \java\seedu\address\model\Model.java
``` java
    /** Loads the previous state. Returns the command attached to the state to be printed. */
    String loadPreviousState() throws StateException;

    /** Loads the next state. Returns the command attached to the state to be printed. */
    String loadNextState() throws StateException;
    
    /** Raises event to change file path of data */
    void changeFilePath(String filePath);

    /** Adds a command preset to the current list */
    void addPreset(CommandPreset commandPreset);

    /** Removes a command preset to the current list. Returns the description of the removed preset to be printed. */
    String removePreset(int index) throws IllegalValueException;
```
###### \java\seedu\address\model\ModelManager.java
``` java
    private final States states;
    private final UserPrefs userPrefs;
```
###### \java\seedu\address\model\ModelManager.java
``` java
        states = new StatesManager(new TaskBookState(taskBook));
        this.userPrefs = userPrefs;
```
###### \java\seedu\address\model\ModelManager.java
``` java
        states = new StatesManager(new TaskBookState(taskBook));
        this.userPrefs = userPrefs;
```
###### \java\seedu\address\model\ModelManager.java
``` java
    /** Raises an event to indicate the config has changed */
    @Override
    public void changeFilePath(String filePath) {
        raise(new FilePathChangedEvent(filePath));
    }
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public void addPreset(CommandPreset commandPreset) {
        userPrefs.addPreset(commandPreset);
        raise(new PresetChangedEvent(userPrefs));
    }
    
    @Override
    public String removePreset(int index) throws IllegalValueException {
        String removedCommandDesc = userPrefs.removePreset(index);
        raise(new PresetChangedEvent(userPrefs));
        return removedCommandDesc;
    }
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public void saveState(String commandText) {
        states.saveState(new TaskBookState(taskBook, commandText));
    }

    @Override
    public String loadPreviousState() throws StateException {
        return loadState(states.loadPreviousState());
    }

    @Override
    public String loadNextState() throws StateException {
        return loadState(states.loadNextState());
    }
    
    private String loadState(TaskBookState newState) {
        taskBook.resetData(newState.getState());
        indicateTaskBookChanged();
        return newState.getCommand();
    }
```
###### \java\seedu\address\model\States.java
``` java
package seedu.address.model;

import seedu.address.commons.exceptions.StateException;

/**
 * The API of the States component.
 */
public interface States {
    /** Saves a state to the state list. */
    public void saveState(TaskBookState newState);
    
    /** Loads the previous state. */
    public TaskBookState loadPreviousState() throws StateException;

    /** Loads the next state. */
    public TaskBookState loadNextState() throws StateException;
    
}
```
###### \java\seedu\address\model\StatesManager.java
``` java
package seedu.address.model;

import java.util.ArrayList;

import seedu.address.commons.exceptions.StateException;

public class StatesManager implements States{
    /**
     * States are stored as a list, with currentState pointing to the current state of the task book in the model.
     */
    private ArrayList<TaskBookState> states = new ArrayList<>();
    private int currentState = 0;
    
    private final int MAX_STATES = 10; // Does not include initial state
    public final static String MESSAGE_NO_PREV_STATE = "No previous state to load.";
    public final static String MESSAGE_MAX_STATES_EXCEEDED = "Maximum undos exceeded.";
    public final static String MESSAGE_NO_NEXT_STATE = "No next state to load.";
    
    public StatesManager(TaskBookState initialState){
        states.add(initialState);
    }


    public void saveState(TaskBookState newState){
        // When a state is saved, all "future states" i.e. states that have been undone are overwritten.
        while(states.size() - 1 > currentState){
            states.remove(states.size() - 1);
        }
        
        states.add(newState);
        if(currentState == MAX_STATES){
            // Exceeded cap, delete the first state
            states.remove(0);
        }else{
            currentState++;
        }
    }


    public TaskBookState loadPreviousState() throws StateException{
        checkHasPreviousState();
        // Note: Unlike loadNextState(), return current state command, but previous state data.
        String commandString = getCurrentState().getCommand();
        currentState--;
        return new TaskBookState(getCurrentState().getState(), commandString);
    }


    private void checkHasPreviousState() throws StateException {
        if(currentState == 0){
            assert !states.isEmpty();
            if(states.get(0).getCommand().equals(TaskBookState.INITIAL_STATE)){
                throw new StateException(MESSAGE_NO_PREV_STATE);
            }else{
                // First state is not the initial state.
                // This means it was deleted by saveState() due to hitting max capacity
                throw new StateException(MESSAGE_MAX_STATES_EXCEEDED);
            }
        }
    }

    public TaskBookState loadNextState() throws StateException{
        checkHasNextState();
        // Note: Unlike loadNextState(), return current state command and data.
        currentState++;
        return getCurrentState();
    }


    private void checkHasNextState() throws StateException {
        if(currentState == states.size() - 1){
            throw new StateException(MESSAGE_NO_NEXT_STATE);
        }
    }

    private TaskBookState getCurrentState() {
        return states.get(currentState);
    }
    
}
```
###### \java\seedu\address\model\task\DateParser.java
``` java
package seedu.address.model.task;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.List;

import org.antlr.runtime.tree.Tree;

import com.joestelmach.natty.*;

import seedu.address.commons.exceptions.IllegalValueException;
/**
 * Wrapper class for Natty.
 * Parses dates from a string.
 */
public class DateParser {
    private static final String RELATIVE_DATE_STRING = "RELATIVE_DATE";
    private static final String EXPLICIT_DATE_STRING = "EXPLICIT_DATE";
    private static final String TIME_STRING = "EXPLICIT_TIME";
    
    private static Parser nattyParser = new Parser();
    
    /*
     * Parses a date time from a string using natty.
     */
    public static LocalDateTime parseDate(String dateString) throws IllegalValueException{
        DateGroup dateGroup = parseNatty(dateString);
        LocalDateTime parsedDate = getDateTime(dateGroup);
        if(!searchDateTree(dateGroup, TIME_STRING)){
            parsedDate = parsedDate.withHour(0).withMinute(0).withSecond(0).withNano(0);
        }
        return parsedDate;
    }
    
    /*
     * Edits a date based on a string parsed using natty.
     * Only edits the old date or time if a new date or time is provided respectively.
     * E.g.
     * dateString: 5pm => Only Time changes
     * dateString: tomorrow => Only Date changes
     * dateString: 5pm tomorrow => Both change
     */
    public static LocalDateTime editDate(String dateString, LocalDateTime oldDatetime) throws IllegalValueException {
        DateGroup dateGroup = parseNatty(dateString);
        LocalDateTime parsedDate = getDateTime(dateGroup);
        LocalDateTime newDate = oldDatetime;
        if(searchDateTree(dateGroup, RELATIVE_DATE_STRING) || searchDateTree(dateGroup, EXPLICIT_DATE_STRING)){
            newDate = newDate.withYear(parsedDate.getYear()).withDayOfYear(parsedDate.getDayOfYear());
        }
        if(searchDateTree(dateGroup, TIME_STRING)){
            newDate = newDate.withHour(parsedDate.getHour()).withMinute(parsedDate.getMinute());
        }
        return newDate;
    }
    
```
###### \java\seedu\address\model\task\DateParser.java
``` java
    
    /*
     * Searches natty's generated date tree for a string value
     * Used to check if the date string has a date or time by searching the date tree generated by natty.
     * Refer to natty documentation for the tree layout.
     */
    private static boolean searchDateTree(DateGroup dateGroup, String toSearch) {
        Tree textGroups = dateGroup.getSyntaxTree().getChild(0);
        for(int i = 0; i < textGroups.getChildCount(); i++){
            String text = textGroups.getChild(i).getText();
            if(text.equals(toSearch)){
                return true;
            }
        }
        return false;
    }
    
    /*
     * Parses a date using natty.
     */
    private static DateGroup parseNatty(String dateString) throws IllegalValueException{
        if(dateString == null){
            throw new IllegalValueException("Missing date parameter.");
        }
        List<DateGroup> dates = nattyParser.parse(dateString);
        if(dates.isEmpty() || dates.get(0).getDates().isEmpty()){
            throw new IllegalValueException("Date not parsable.");
        }
        return dates.get(0);
    }
    
    /*
     * Converts a natty DateGroup into a LocalDateTime.
     */
    private static LocalDateTime getDateTime(DateGroup dateGroup){
        return LocalDateTime.ofInstant(dateGroup.getDates().get(0).toInstant(), ZoneId.systemDefault());
    }
    
}
```
###### \java\seedu\address\model\task\DateTime.java
``` java
package seedu.address.model.task;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import seedu.address.commons.exceptions.IllegalValueException;
/**
 * Represents a DatedTask's date and time in the task book.
 * Guarantees: immutable; is valid as declared in {@link #isValidLength(String)}
 */
public class DateTime {

    public static final DateTimeFormatter DATE_DISPLAY_FORMATTER = DateTimeFormatter.ofPattern("MM-dd-yyyy HH:mm");
    public static final String PARAM_NOT_SPECIFIED = "-1";

    private final LocalDateTime datetime;
    
    /**
     * Validates given date and time.
     *
     * @throws IllegalValueException if given date or time string is invalid.
     */
    public DateTime(String dateString) throws IllegalValueException {
        this(dateString, false);
    }


    public DateTime(String dateString, boolean fromXML) throws IllegalValueException {
        assert dateString != null;
        dateString = dateString.trim();
        if(fromXML){
            datetime = LocalDateTime.parse(dateString, DATE_DISPLAY_FORMATTER);
        }else{
            datetime = DateParser.parseDate(dateString);
        }
    }

    
    public DateTime(String dateString, DateTime oldDatetime) throws IllegalValueException {
        assert dateString != null;
        assert oldDatetime != null;
        dateString = dateString.trim();
        datetime = DateParser.editDate(dateString, oldDatetime.datetime);
    }
    
    public DateTime (LocalDateTime datetime) {
        this.datetime = datetime;
    }


    @Override
    public String toString() {
        return datetime.format(DATE_DISPLAY_FORMATTER);
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DateTime // instanceof handles nulls
                && this.datetime.equals(((DateTime) other).datetime)); // state check
    }

    @Override
    public int hashCode() {
        return this.datetime.hashCode();
    }
    
    public LocalDateTime getDateTime(){
        return datetime;
    }
}
```
###### \java\seedu\address\model\task\DoneFlag.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;
/**
 * Represents a done status in the task book.
 * Guarantees: immutable; is valid as declared in {@link #isValidLength(String)}
 */
public class DoneFlag {
    
    public static final String DONE = "Done";
    public static final String NOT_DONE = "Not done";

    public static final String MESSAGE_FLAG_CONSTRAINTS = "Done flag should be \"" + DONE + "\" or \"" + NOT_DONE + "\".";
    
    public final String done;
    
    /**
     * Validates given done value.
     *
     * @throws IllegalValueException if given doneFlag string is invalid.
     */

    public DoneFlag(String value) throws IllegalValueException {
        assert value != null;
        value = value.trim();
        if(!isValidFlag(value)){
            throw new IllegalValueException(MESSAGE_FLAG_CONSTRAINTS);
        }
        done = value;
    }

    private boolean isValidFlag(String test) {
        return test.equals(DONE) || test.equals(NOT_DONE);
    }
    
    @Override
    public String toString() {
        return this.done;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DoneFlag // instanceof handles nulls
                && this.done.equals(((DoneFlag) other).done)); // state check
    }

    @Override
    public int hashCode() {
        return done.hashCode();
    }
    
    public boolean isDone(){
        return done.equals(DONE);
    }

}
```
###### \java\seedu\address\model\task\Length.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's length.
 * Functions as a wrapper for TimeInterval
 */
public class Length {

    private final TimeInterval timeInterval;
    public final static String NO_INTERVAL = "";
    public final static String DEFAULT_INTERVAL = "1h";
    private boolean hasInterval = true;
    /**
     * Stores given interval. Validation of interval is done by TimeInterval class.
     *
     * @throws IllegalValueException if given information string is invalid.
     */
    public Length(String interval) throws IllegalValueException {
        assert interval != null;
        interval = interval.trim();
        
        if(interval.equals(NO_INTERVAL)){
            hasInterval = false;
            interval = DEFAULT_INTERVAL;
            
        }
        this.timeInterval = new TimeInterval(interval);
    }

    public boolean isValid(){
        return hasInterval;
    }
    
    @Override
    public String toString() {
        if(!hasInterval){
            return NO_INTERVAL;
        }else{
            return this.timeInterval.toString();
        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Recurrance // instanceof handles nulls
                && this.timeInterval.equals(((Length) other).timeInterval)); // state check
    }

    @Override
    public int hashCode() {
        return this.timeInterval.hashCode();
    }
    
    public int getAsMinutes(){
        return timeInterval.getAsMinutes();
    }
}
```
###### \java\seedu\address\model\task\TimeInterval.java
``` java
package seedu.address.model.task;

import java.util.HashMap;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.address.commons.exceptions.IllegalValueException;

public class TimeInterval {
    public static final String MESSAGE_TIME_INTERVAL_CONSTRAINTS = "Time interval should be a positive number followed by a character e.g 5h, 1d, 2m, 1w. " +
            "Acceptable time units are m/min/mins (minutes) h/hr/hrs (hours), d/day/days (days), w/week/weeks (weeks)";

    //public static final String INTERVAL_VALIDATION_REGEX = "\\d+\\c";
    private static final Pattern INTERVAL_VALIDATION_REGEX = Pattern.compile("(?<length>\\d+)(?<unit>[a-zA-Z]+)");
    private static HashMap<String, Integer> INTERVAL_TO_MINUTES = new HashMap<>();

```
###### \java\seedu\address\model\task\TimeInterval.java
``` java
    
    static
    {
        INTERVAL_TO_MINUTES.put("m", 1);
        INTERVAL_TO_MINUTES.put("h", 60);
        INTERVAL_TO_MINUTES.put("d", 24 * 60);
        INTERVAL_TO_MINUTES.put("w", 7 * 24 * 60);
        
```
###### \java\seedu\address\model\task\TimeInterval.java
``` java
    }
    
    public final String intervalString;
    public final int length;
    public String unit;
    
    /**
     * Validates given information.
     *
     * @throws IllegalValueException if given information string is invalid.
     */
```
###### \java\seedu\address\model\task\TimeInterval.java
``` java
    
    private boolean isValidInterval(int length, String unit){
        if(!INTERVAL_TO_MINUTES.containsKey(unit)){
            return false;
        }
        if(length == 0){
            return false;
        }
        return true;
    }
    
    public int getAsMinutes(){
        return length * INTERVAL_TO_MINUTES.get(unit);
    }
    
    @Override
    public String toString() {
        return length + unit;
    }
    
    public String getUnit(){
    	return unit;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TimeInterval // instanceof handles nulls
                && this.length == ((TimeInterval) other).length
                && this.unit.equals(((TimeInterval) other).unit)); // state check
    }

    @Override
    public int hashCode() {
        return Objects.hash(length, unit);
    }
}
```
###### \java\seedu\address\model\TaskBookState.java
``` java
/**
 * Represents a state of the task book.
 * 
 * An task book state consists of a state and a command.
 * The state stores the state of the task book at the point the command was executed.
 * The command stores the command that was executed to achieve this state.
 * 
 * Used simply as a wrapper for two variables.
 */
public class TaskBookState {
    private final TaskBook state;
    private final String command;
    public static final String INITIAL_STATE = "Initial state";
    
    public TaskBookState(TaskBook state){
        this(state, INITIAL_STATE);
    }
    
    public TaskBookState(TaskBook state, String command){
        this.state = new TaskBook(state);
        this.command = command;
    }
    
    public TaskBook getState(){
        return state;
    }
    
    public String getCommand(){
        return command;
    }
}
```
###### \java\seedu\address\model\UserPrefs.java
``` java
    
    // This list stores the list of command presets, which are serialized to preferences.json
    public ArrayList<CommandPreset> commandPresets = new ArrayList<>();
    
    // This list stores an observable list of command presets, which the cards in the PresetListPanel are binded to.
    @JsonIgnore 
    private ObservableList<CommandPreset> internalList = FXCollections.observableArrayList();
    
    /*
     * Both lists store the exact same data.
     * 
     * One is used to display on the panel and the other is used to save to a JSON file.
     * 
     * Ideally I'd use just one list, but PresetListPanel can only bind to ObservableList, and
     * ObservableList cannot be serialized to JSON.
     * 
     * So, I used separate lists. A bit hacky, but I didn't really have a choice...
     */
    
```
###### \java\seedu\address\model\UserPrefs.java
``` java
    public ObservableList<CommandPreset> getCommandPresets(){
        // Initialize internalList after JSON has been loaded
        internalList = FXCollections.observableArrayList(commandPresets);
        return internalList;
    }
```
###### \java\seedu\address\model\UserPrefs.java
``` java
    public void addPreset(CommandPreset commandPreset) {
        assert commandPreset != null;
        commandPresets.add(commandPreset);
        internalList.add(commandPreset);
    }

    public String removePreset(int index) throws IllegalValueException{
        if(index < 0 || index >= commandPresets.size()){
            throw new IllegalValueException("Index out of range.");
        }
        String removedCommandDesc = commandPresets.get(index).getDescription();
        commandPresets.remove(index);
        internalList.remove(index);
        return removedCommandDesc;
    }
```
###### \java\seedu\address\storage\Storage.java
``` java
    /**
     * Saves the current user preferences to the hard disk.
     */
    void handlePresetChangedEvent(PresetChangedEvent event);
```
###### \java\seedu\address\storage\StorageManager.java
``` java
    @Override
    @Subscribe
    public void handlePresetChangedEvent(PresetChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Local preset data changed, saving to file"));
        try {
            saveUserPrefs(event.data);
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }
```
###### \java\seedu\address\storage\XmlAdaptedTask.java
``` java

    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName().fullName;
        priority = source.getPriority().toString();
        information = source.getInformation().fullInformation;
        done = source.getDoneFlag().toString();
        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
        
        isDated = source.isDated();
        if(isDated){
            ReadOnlyDatedTask datedSource = (ReadOnlyDatedTask) source;
            dateTime = datedSource.getDateTime().toString();
            length = datedSource.getLength().toString();
            recurrance = datedSource.getRecurrance().toString();
        }
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        final Name name = new Name(this.name);
        final Priority priority = new Priority(this.priority);
        final Information information = new Information(this.information);
        final DoneFlag done = new DoneFlag(this.done);
        final UniqueTagList tags = new UniqueTagList(taskTags);
        if(isDated){
            final DateTime dateTime = new DateTime(this.dateTime, true);
            final Length length = new Length(this.length);
            final Recurrance recurrance = new Recurrance(this.recurrance);
            return new DatedTask(name, dateTime, length, recurrance, priority, information, done, tags);
        }else{
            return new Task(name, priority, information, done, tags);
        }
    }
    
```
###### \java\seedu\address\ui\CommandBox.java
``` java
    @Subscribe
    private void handleCommandPresetSelected(CommandPresetSelectedEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(event,"Selected command preset: " + event.getCommand()));
        commandTextField.setText(event.getCommand());
        handleCommandInputChanged();
        commandTextField.setText(event.getCommand());
    }
```
###### \java\seedu\address\ui\MainWindow.java
``` java
    private PresetListPanel presetListPanel;
```
###### \java\seedu\address\ui\MainWindow.java
``` java
    @FXML
    private AnchorPane presetListPanelPlaceholder;
```
###### \java\seedu\address\ui\MainWindow.java
``` java
        presetListPanel = PresetListPanel.load(primaryStage, getPresetListPlaceholder(), userPrefs.getCommandPresets());
```
###### \java\seedu\address\ui\MainWindow.java
``` java
    public AnchorPane getPresetListPlaceholder() {
        return presetListPanelPlaceholder;
    }
```
###### \java\seedu\address\ui\MainWindow.java
``` java
    public PresetListPanel getPresetListPanel() {
        return this.presetListPanel;
    }
```
###### \java\seedu\address\ui\PresetCard.java
``` java
package seedu.address.ui;

import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import seedu.address.model.CommandPreset;
import seedu.address.model.task.ReadOnlyDatedTask;
import seedu.address.model.task.ReadOnlyTask;

public class PresetCard extends UiPart{

    private static final String FXML = "PresetListCard.fxml";
    private static final TaskStyleMapping styler = TaskPropertyMapping.getInstance();

    @FXML
    private HBox cardPane;
    @FXML
    private Label presetIndex;
    @FXML
    private Label description;
    @FXML
    private Tooltip tooltip;

    private CommandPreset commandPreset;
    private int index;
    
    public PresetCard(){

    }

    public static PresetCard load(CommandPreset commandPreset, int index){
        PresetCard card = new PresetCard();
        card.commandPreset = commandPreset;
        card.index = index;
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {
        description.setText(commandPreset.getDescription());
        presetIndex.setText(index + ". ");
        tooltip.setText(commandPreset.getCommand());
    }
    
    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox)node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \java\seedu\address\ui\PresetListPanel.java
``` java
package seedu.address.ui;

import javafx.application.Platform;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.SplitPane;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import seedu.address.commons.events.ui.CommandPresetSelectedEvent;
import seedu.address.commons.events.ui.TaskPanelSelectionChangedEvent;
import seedu.address.model.CommandPreset;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.commons.core.LogsCenter;

import java.util.logging.Logger;

/**
 * Panel containing the list of presets.
 */
public class PresetListPanel extends UiPart {
    private final Logger logger = LogsCenter.getLogger(PresetListPanel.class);
    private static final String FXML = "PresetListPanel.fxml";
    private VBox panel;
    private AnchorPane placeHolderPane;

    @FXML
    private ListView<CommandPreset> presetListView;

    public PresetListPanel() {
        super();
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static PresetListPanel load(Stage primaryStage, AnchorPane presetListPlaceholder,
                                       ObservableList<CommandPreset> presetList) {
        PresetListPanel presetListPanel =
                UiPartLoader.loadUiPart(primaryStage, presetListPlaceholder, new PresetListPanel());
        presetListPanel.configure(presetList);
        return presetListPanel;
    }

    private void configure(ObservableList<CommandPreset> presetList) {
        setConnections(presetList);
        addToPlaceholder();
    }

    private void setConnections(ObservableList<CommandPreset> presetList) {
        presetListView.setItems(presetList);
        presetListView.setCellFactory(listView -> new PresetListViewCell());
        setEventHandlerForSelectionChangeEvent();
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    private void setEventHandlerForSelectionChangeEvent() {
        presetListView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                logger.fine("Selection in preset list panel changed to : '" + newValue + "'");
                raise(new CommandPresetSelectedEvent(newValue));
            }
        });
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            presetListView.scrollTo(index);
            presetListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class PresetListViewCell extends ListCell<CommandPreset> {

        public PresetListViewCell() {
        }

        @Override
        protected void updateItem(CommandPreset commandPreset, boolean empty) {
            super.updateItem(commandPreset, empty);

            if (empty || commandPreset == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(PresetCard.load(commandPreset, getIndex() + 1).getLayout());
            }
        }
    }

}
```
###### \java\seedu\address\ui\StatusBarFooter.java
``` java
    @Subscribe
    public void handleFilePathChangedEvent(FilePathChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Setting last updated status to " + event.filePath));
        setSaveLocation(getFormattedPath(event.filePath));
    }
    
    private String getFormattedPath(String filepath){
        if(filepath.matches("^.:.*")){
            // Drive path e.g. C:\...
            return filepath;
        }
        return "./" + filepath;
    }
```
###### \java\seedu\address\ui\TaskCard.java
``` java
    @FXML
    public void initialize() {
        name.setText(task.getName().fullName);
        id.setText(Integer.toString(displayedIndex));
        setOrNullText(priority, "Priority: ", task.getPriority().getDisplayedAlias());
        setOrNullText(information, "Info: ", task.getInformation().toString());
        setOrNullText(done, task.getDoneFlag().toString());
        if(task.isDated()){
            ReadOnlyDatedTask datedTask = (ReadOnlyDatedTask) task;
            setOrNullText(datetime, "Date: ",
                    datedTask.getDateTime().toString() + (datedTask.hasValidLength() ? " - " + datedTask.getDateTimeEnd().toString() : ""));
            setOrNullText(length, "");
            setOrNullText(recurrance, "Repeat every ", datedTask.getRecurrance().toString());
        }else{
            setOrNullText(datetime, "");
            setOrNullText(length, "");
            setOrNullText(recurrance, "");
        }
        tags.setText(task.tagsString());
        removeUnnecessaryLabels();
        style();
    }

    public void setOrNullText(Label label, String value){
        setOrNullText(label, "", value);
    }
    
    public void setOrNullText(Label label, String prefix, String value){
        if(value.equals("")){
            label.setText("");
        }else{
            label.setText(prefix + value);
        }
    }
    
    public void removeUnnecessaryLabels(){
        VBox sub = ((VBox) (datetime.getParent()));
        sub.getChildren().removeIf(lbl -> lbl instanceof Label && ((Label) lbl).getText().equals(""));
    }
    
    public void style(){
        StringBuilder styleString = new StringBuilder();
        // Style based on property
        styleString.append(styler.getLightPriorityColour(task.getPriority().toString()));
        // Style based on done
        styleString.append(styler.getLightDoneColour(task.getDoneFlag().toString()));
        light.setStyle(styleString.toString());
        //styleString = new StringBuilder();
        //styleString.append(styler.getCardDoneColour(task.getDoneFlag().toString()));
        //taskPane.setStyle(styleString.toString());
        
    }
    
```
###### \java\seedu\address\ui\TaskPropertyMapping.java
``` java
package seedu.address.ui;

import java.util.HashMap;

/*
 * Class for converting task properties to CSS style strings which
 * are used to style UI elements.
 * 
 * Task properties must be a string.
 * 
 * Styles are usually strings in the form:
 * style-name : value;
 * which can be easily applied by using setStyle();
 */

public class TaskPropertyMapping implements TaskStyleMapping{
    private final static String PROPERTY_BACKGROUND = "-fx-background-color";
    
    private final static PropertyMap lightPriorityMap;
    private final static PropertyMap lightDoneMap;
    private final static PropertyMap cardDoneMap;
    
    private static TaskPropertyMapping instance = null;
    
    static {
        // Light - Priority : Background color
        lightPriorityMap = new PropertyMap(PROPERTY_BACKGROUND);
        lightPriorityMap.addTo("VERYHIGH", "radial-gradient(center 50% 50%, radius 50%, #E43122, #C92C17)");
        lightPriorityMap.addTo("HIGH", "radial-gradient(center 50% 50%, radius 50%, #F3BB22, #E2AA11)");
        lightPriorityMap.addTo("MEDIUM", "radial-gradient(center 50% 50%, radius 50%, #22C847, #22A73B)");
        lightPriorityMap.addTo("LOW", "radial-gradient(radius 100%, #029DAC, #028C9B)");
        lightPriorityMap.addTo("VERYLOW", "radial-gradient(radius 100%, #3408B1, #2C08A1)");
        
        // Light - Done : Background color
        lightDoneMap = new PropertyMap(PROPERTY_BACKGROUND);
        lightDoneMap.addTo("Done", "radial-gradient(center 50% 50%, radius 50%, #999999, #777777)");
        
        // Card - Done : Background color
        cardDoneMap = new PropertyMap(PROPERTY_BACKGROUND);
        cardDoneMap.addTo("Done", "");
        cardDoneMap.addTo("Not done", "");
    }
    
    // Singleton
    private TaskPropertyMapping(){}
    
    public static TaskPropertyMapping getInstance(){
        if(instance == null){
            instance = new TaskPropertyMapping();
        }
        return instance;
    }
    
    @Override
    public String getLightPriorityColour(String priority){
        return lightPriorityMap.get(priority);
    }

    @Override
    public String getLightDoneColour(String done) {
        return lightDoneMap.get(done);
    }
    
    @Override
    public String getCardDoneColour(String done) {
        return cardDoneMap.get(done);
    }
    
    /*
     * Wrapper class for a hash map which maps Task Property : CSS Style String.
     * Makes adding property constants easier.
     * Also, returns a default value if the requested property does not exist.
     */
    private static class PropertyMap{
        private final String property;
        public final HashMap<String, String> map = new HashMap<String, String>();
        
        public PropertyMap(String property){
            this.property = property;
        }
        
        public void addTo(String key, String value){
            map.put(key, getStyleString(property, value));
        }
        
        public String get(String key){
            if(map.containsKey(key)){
                return map.get(key);
            }
            return ""; // No property
        }
    }
    
    /*
     * Converts a CSS property and value into the CSS style string format.
     */
    private static String getStyleString(String property, String value){
        return property + ": " + value + ";";
    }

}
```
###### \java\seedu\address\ui\TaskStyleMapping.java
``` java
package seedu.address.ui;

/*
 * API for a class that converts Task properties to CSS properties
 * to style.
 */
public interface TaskStyleMapping {
    /* Returns a colour style based on the Task's priority property.*/
    public String getLightPriorityColour(String priority);
    /* Returns a colour style based on the Task's done property.*/
    public String getLightDoneColour(String done);
    /* Returns a colour style based on the Task's done property.*/
    public String getCardDoneColour(String done);
}
```
###### \resources\view\DarkTheme.css
``` css
 * Many of the above properties were changed too
 * */

#taskPane {
	-fx-text-fill: #888888;
    -fx-padding: 10;
    -fx-border-insets: 5 10 5 10;
    -fx-background-insets: 5 10 5 10;
}

#presetCard {
	-fx-text-fill: #888888;
    -fx-background-color: transparent;
}

#commandTypeLabel {
    -fx-font-size: 11px;
    -fx-text-fill: #F70D1A;
}

#filterField, #taskListView, #taskListPanel {
	-fx-background-color: #FAFAFA;
    -fx-effect: innershadow(gaussian, white, 10, 0, 0, 0);
}

.list-cell{
	
}

.list-cell:odd{
	-fx-background-color: #FAFAFA;
}

.list-cell:even{
	-fx-background-color: #F5F5F5;
}

.list-cell:filled:selected:focused, .list-cell:filled:selected {
    -fx-background-color: #AAAAFF;
}

.list-view{
	-fx-background-color: #FFFFFF;
}
.list-view:focused{
	-fx-background-color: #FFFFFF;
}
.list-cell:hover{
	-fx-background-color: #CCCCFF;
}
#indexLblContainer {
	-fx-background-color: linear-gradient(#575757, #454545);
	-fx-padding: 5;
}

.text-area .content{
	-fx-background-color: #CCCCCC;
}

.text-field{
	-fx-background-color: #CCCCCC;
	-fx-prompt-text-fill: #555555;
}

.idLabel {
    -fx-font-size: 16px;
    -fx-text-fill: #FFFFFF !important;
}

.tooltip {
    -fx-text-fill: #000000;
    -fx-background-radius: 0 0 0 0;
    -fx-background-color: linear-gradient(#FFFFFF, #FAFAFA);
}

#error {
    -fx-background-color: #FF0000 !important;
}
    
```
###### \resources\view\MainWindow.fxml
``` fxml
   </children>
</VBox>
```
###### \resources\view\PresetListCard.fxml
``` fxml
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import java.net.URL?>
<HBox id="presetCard" fx:id="cardPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane HBox.hgrow="ALWAYS" >
            <columnConstraints>
                <ColumnConstraints hgrow="ALWAYS" minWidth="10.0" prefWidth="150.0" />
            </columnConstraints>
            <children>
                <VBox alignment="CENTER_LEFT" maxHeight="150.0" minHeight="0" GridPane.columnIndex="0">
                    <stylesheets>
                        <URL value="@DarkTheme.css" />
                        <URL value="@Extensions.css" />
                    </stylesheets>
                    <padding>
                        <Insets bottom="5" left="15" right="5" top="5" />
                    </padding>

                    <children>
                        <HBox>
                        	<Label minWidth="30.0" fx:id="presetIndex" styleClass="cell_big_label" text="\$index" />
                        	<Label fx:id="description" styleClass="cell_big_label" text="\$description">
	                        	<tooltip>
					                <Tooltip styleClass="tooltip" fx:id="tooltip" text="\$tooltip"/>
					            </tooltip>
                        	</Label>
                        </HBox>
                    </children>
                </VBox>
            </children>
        </GridPane>
    </children>
</HBox>
```
###### \resources\view\PresetListPanel.fxml
``` fxml
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.*?>
<?import java.net.URL?>
<VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.PresetListPanel" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
    <children>
        <ListView fx:id="presetListView" VBox.vgrow="ALWAYS" />
    </children>
</VBox>
```
